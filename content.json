[{"title":"C语言风格字符串","date":"2017-02-04T10:38:12.000Z","path":"2017/02/04/C语言风格字符串/","text":"C语言风格字符串 字符串的长度： C语言风格的字符串末尾有一个‘\\0’。 比如： * = \"HelloWorld\"; ```12345678910111213141516171819202122232425262728293031 在堆内存中会有一个字符数组，它存储的是“HelloWorld”末尾有一个“\\0” 在栈内存中会有一个字符指针，名字为str指向字符数组0号位置的字符‘H’ 如下图所示：![这里写图片描述](http://img.blog.csdn.net/20170204173349713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGVsbG90b21oYWhh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) - **那么如何求字符串的长度呢？** - 定义一个指针p指向0号位置，然后再定义一个变量初始化为0；把指针p不断往后移动，移动的过程中将那个变量不断加一；最终p所指向的字符是&apos;\\0&apos;;这时候停止循环返回定义的变量的值。 ### 求字符串的长度的代码：```c++#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;const int Max=32;//求字符串的长度int strLength(char* str)&#123; int count=0; //count记录字符串的长度 char* p=str; //定义一个指针指向第一个字符 while(*p++)&#123; //当p没有指向&apos;\\0&apos;时，则一直循环往后移动，直到指向&apos;\\0&apos; count++; //移动的过程中count增大 &#125; return count;&#125;int main(int argc, char **argv) &#123; char* str=(char*)malloc(sizeof(char)*Max); scanf(&quot;%s&quot;,str); printf(&quot;%d %d\\n&quot;,strLength(str),strlen(str)); //strLength为我们自定义的求长度的方法，strlen为c语言自带的方法 return 0;&#125; 字符串的拷贝： 当考虑目标字符串dest比源字符串src短时： 当考虑目标字符串dest比源字符串src长时： 求字符串的拷贝的代码：12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;const int Max=32;//字符串的拷贝void strCopy(char* dest,char* src)&#123; char* p=dest; char* q=src; while(*p++=*q++)&#123; //不断把q所指向的字符向p所指向的字符移动，直到q所指向的字符为'\\0' &#125;&#125;int main(int argc, char **argv) &#123; char* dest=(char*)malloc(Max*sizeof(char)); char* src=(char*)malloc(Max*sizeof(char)); gets(dest); gets(src); strCopy(dest,src); //自己编写的字符串拷贝函数 printf(\"%s\\n\",dest); free(dest); free(src); dest=(char*)malloc(Max*sizeof(char)); src=(char*)malloc(Max*sizeof(char)); gets(dest); gets(src); strcpy(dest,src); //c语言自带的字符串拷贝函数 printf(\"%s\\n\",dest); free(dest); free(src); return 0;&#125; 字符串的连接： 首先要保证目标串的尾部，有足够的空间容纳源字符串； 步骤： 1.求目标字符串的长度 2.将源字符串复制到目标串的尾部 字符串的连接的代码：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;const int Max=32;//字符串的连接void strCat(char* dest,char* src)&#123; int len=strlen(dest); //求目标字符串的长度 char* p=dest+len; //指针指向目标串的末尾，也就是指向dest字符串的'\\0'的位置 strcpy(p,src); //将源串拷贝至目标串末尾&#125;int main(int argc, char **argv) &#123; char* dest=(char*)malloc(Max*sizeof(char)); char* src=(char*)malloc(Max*sizeof(char)); gets(dest); gets(src); strCat(dest,src); //自己编写的字符串的连接 printf(\"%s\\n\",dest); free(dest); free(src); dest=(char*)malloc(Max*sizeof(char)); src=(char*)malloc(Max*sizeof(char)); gets(dest); gets(src); strcat(dest,src); //c语言自带字符串的连接 printf(\"%s\\n\",dest); free(dest); free(src); return 0;&#125; 字符串的比较： 原则：相等返回0,小于返回-1,大于返回1 方法： 1.定义两个指针，分别指向两个字符串 2.两个指针往后移动，直到指向的连个字符不相等时比较大小 3.当都指向了末尾，且之前的都相等，则返回0； 4.当长度不相等，且两个指针有一个指向的’\\0’，则长度长的大 字符串的比较的代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;const int Max=32;//比较两个字符串的大小int strCompare(char* s1,char* s2)&#123; char* p=s1; char* q=s2; while(*p==*q&amp;&amp;*p&amp;&amp;*q)&#123; //当指向的字符相等，且都没有指向末尾'\\0'时则循环往后移动指针 p++; q++; &#125; if(*p-*q==0)&#123; //当都指向末尾'\\0'时，则相等 return 0; &#125;else&#123; return *p&gt;*q?1:-1; //指向的字符不等时，比较大小；或者有一个指向'\\0'也比较大小 &#125;&#125;int main(int argc, char **argv) &#123; char* s1=(char*)malloc(Max*sizeof(char)); char* s2=(char*)malloc(Max*sizeof(char)); gets(s1); gets(s2); printf(\"%d\\n\",strCompare(s1,s2)); //自己写的字符串比较函数 free(s1); free(s2); s1=(char*)malloc(Max*sizeof(char)); s2=(char*)malloc(Max*sizeof(char)); gets(s1); gets(s2); printf(\"%d\\n\",strcmp(s1,s2)); //系统自带的字符串比较函数 free(s1); free(s2); return 0;&#125; 字符串的大小写转换： 大写转化为小写：指针指向的字符加上32 小写转化为大写：指针指向的字符加减32 字符串的大写转化为小写：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;const int Max=32;//字符串转小写void strLower(char* s)&#123; char* p=s; while(*p)&#123; if(*p&gt;='A'&amp;&amp;*p&lt;='Z')&#123; *p+=32; //遇到大写字符，加上32 &#125; p++; &#125;&#125;int main(int argc, char **argv) &#123; char* s=(char*)malloc(Max*sizeof(char)); gets(s); strLower(s); //自己写的大写转化为小写 printf(\"%s\\n\",s); free(s); s=(char*)malloc(Max*sizeof(char)); gets(s); strlwr(s); //c语言自带转化为小写 printf(\"%s\\n\",s); free(s); return 0;&#125; 字符串的小写转化为大写：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;const int Max=32;//字符串转大写void strUper(char* s)&#123; char* p=s; while(*p)&#123; if(*p&gt;='a'&amp;&amp;*p&lt;='z')&#123; *p-=32; //遇到小写字符，减去32 &#125; p++; &#125;&#125;int main(int argc, char **argv) &#123; char* s=(char*)malloc(Max*sizeof(char)); gets(s); strUper(s); //自己写的小写转化为大写 printf(\"%s\\n\",s); free(s); s=(char*)malloc(Max*sizeof(char)); gets(s); strupr(s); //c语言自带转化为大写 printf(\"%s\\n\",s); free(s); return 0;&#125;","tags":[{"name":"c语言","slug":"c语言","permalink":"http://yoursite.com/tags/c语言/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"Digital Roots","date":"2017-02-04T09:09:26.000Z","path":"2017/02/04/Digital-Roots/","text":"Digital Roots 题目来源：[九度1124][1] 原始代码：12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int getsum(int a)&#123; int ans=0; while (a!=0) &#123; int i = a%10; a /= 10; ans += i; &#125; return ans;&#125;int main() &#123; int a; while (scanf(\"%d\", &amp;a)!=EOF) &#123; if (a==0) &#123; break; &#125; while (a&gt;=10) &#123; a = getsum(a); &#125; printf(\"%d\\n\", a); &#125; return 0;&#125; 该代码提交时会一直报错：wrong answer 但是我自己输入时感觉都正确。那是什么原因呢？ 原因：注意题目中：The integer may consist of a large number of digits.也就是说输入的数字可能非常大超过int所表示的范围。 解决办法： 不再用整数变量来保存输入的数字，再利用求模、求商等数学方法得到拆解后的数字。而是转而采用将输入数据当作字符串的技巧，直接将数字以字符串的形式保存起来，再依次遍历这个字符串，通过字符与字符’0’的ascii值的差，计算字符所表示的数字值。 以上方法见：王道机试指南p66 修改后代码：12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int getsum(int a)&#123; int ans=0; while (a!=0) &#123; int i = a%10; a /= 10; ans += i; &#125; return ans;&#125;int main() &#123; char a[1000]; while (scanf(\"%s\", a)!=EOF) &#123;//利用字符串读入数字，作为字符串保存在内存中 int ans=0; //累加变量 for (int i=0; a[i]!=0; i++) &#123; //遍历a中的每一个字符，直到a字符串结尾 ans += (a[i]-'0'); &#125; if (ans==0) &#123; break; &#125; while (ans&gt;=10) &#123; ans = getsum(ans); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"9度oj","slug":"9度oj","permalink":"http://yoursite.com/tags/9度oj/"},{"name":"数位拆解","slug":"数位拆解","permalink":"http://yoursite.com/tags/数位拆解/"}]},{"title":"N-Queens","date":"2017-01-21T10:07:27.000Z","path":"2017/01/21/N-Queens/","text":"N-Queens 问题描述：leetcode:51 [https://leetcode.com/problems/n-queens/][1] 思路： 利用回溯法。 一行一行往下遍历，在每行中又看每一列中的位置是否与之前的放Q的位置形成冲突。 冲突又四种：同行、同列、正斜线、反斜线。 同行不需要考察，因为当一行中放了一个Q时，进行下一行的遍历了。 在进行下一行遍历的函数后面，把放置的Q的那个位置还要重新放“.”;因为还要考察本行后面的位置是否还可以形成答案。 按照思路写的代码：123456789101112131415161718192021222324252627282930313233vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt; &gt; res;//解的集合 vector&lt;string&gt; nQueens(n, string(n, '.'));//其中一个解 solveNQueens(res, nQueens, 0, n);//从第0行开始遍历 return res;&#125;void solveNQueens(vector&lt;vector&lt;string&gt; &gt; &amp;res, vector&lt;string&gt; &amp;nQueens, int row, int &amp;n) &#123; if (row == n) &#123;//当一行一行遍历，到达最后一行后，说明找到一个合格的解，把该解push到解的集合中 res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (isValid(nQueens, row, col, n)) &#123; nQueens[row][col] = 'Q';//当位置合格时，放置Q; solveNQueens(res, nQueens, row + 1, n); nQueens[row][col] = '.';//当本位置以下所有的行中所有的解都解出来后，要把该行重新设置为“.”,以便查看本行后面的位置是否还有可以的位置 &#125;&#125;bool isValid(vector&lt;string&gt; &amp;nQueens, int row, int col, int &amp;n) &#123; //check if the column had a queen before. for (int i = 0; i != row; ++i) if (nQueens[i][col] == 'Q') return false; //check if the 45° diagonal had a queen before. for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) if (nQueens[i][j] == 'Q') return false; //check if the 135° diagonal had a queen before. for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j)//注意： i &gt;= 0 &amp;&amp; j &lt; n if (nQueens[i][j] == 'Q') return false; return true;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"回溯法","slug":"回溯法","permalink":"http://yoursite.com/tags/回溯法/"}]},{"title":"Best Time to Buy and Sell Stock IV","date":"2017-01-18T13:20:43.000Z","path":"2017/01/18/Best-Time-to-Buy-and-Sell-Stock-IV/","text":"Best Time to Buy and Sell Stock IV 问题描述：leetcode:188 Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most k transactions.Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 思路： 按照思路写的代码：1234567891011121314151617int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(k==0||prices.size()&lt;2)&#123; return 0; &#125; &#125; int maxdiff = 0; vector&lt;vector&lt;int&gt; &gt; T(k+1, vector&lt;int&gt; (prices.size(), 0)); for(int i=1; i&lt;k+1; i++)&#123; maxdiff = T[i-1][0] - prices[0] ; for(int j=1; j&lt;prices.size(); j++)&#123; T[i][j] = max(T[i][j-1], maxdiff+prices[j]); maxdiff = max(maxdiff, T[i-1][j] - prices[j]); &#125; &#125; return T[k][prices.size()-1]; &#125; 但是该代码运行时会报错： 也就是说当k＝1000000000时会导致内存出错；所以可以优化代码，也就是当1k&gt;prices.size() 时使用不限定交易次数时的算法（Best Time to Buy and Sell Stock II；leetcode122） 修改之后代码：12345678910111213141516171819202122232425int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(k==0||prices.size()&lt;2)&#123; return 0; &#125; if(k&gt;prices.size())&#123; int ans = 0; for(int i=1; i&lt;prices.size(); i++)&#123; if(prices[i]&gt;prices[i-1])&#123; ans += (prices[i]-prices[i-1]); &#125; &#125; return ans; &#125; int maxdiff = 0; vector&lt;vector&lt;int&gt; &gt; T(k+1, vector&lt;int&gt; (prices.size(), 0)); for(int i=1; i&lt;k+1; i++)&#123; maxdiff = T[i-1][0] - prices[0] ; for(int j=1; j&lt;prices.size(); j++)&#123; T[i][j] = max(T[i][j-1], maxdiff+prices[j]); maxdiff = max(maxdiff, T[i-1][j] - prices[j]); &#125; &#125; return T[k][prices.size()-1];&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Maximum Product Subarray","date":"2017-01-16T14:02:33.000Z","path":"2017/01/16/Maximum-Product-Subarray/","text":"Maximum Product Subarray 问题描述：leetcode:152 Find the contiguous subarray within an array (containing at least one number) which has the largest product.For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. 给定一个数组，找出该数组的连续字串中乘积最大的值；比如给定 [2,3,-2,4]，则答案时当为 [2,3]时，答案为6。 思路： 数组中的元素可以为正也可以为负。 设置两个数组，分别记录包括当前元素在内的字串所能构成的最大和最小值。 至于当前最大（包括当前元素），可能是之前最大乘以当前元素、也可能是前一个元素最小乘以当前元素、也可能是当前元素。 然后根据当前元素最大更新全局元素最大。 该问题是dp问题，也是dp问题中的局部最优和全局最优问题。 代码：12345678910111213141516int maxProduct(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; maxproduct(nums.size(),0); vector&lt;int&gt; minproduct(nums.size(),0); maxproduct[0] = nums[0]; minproduct[0] = nums[0]; int maxans = nums[0]; for (int i=1; i&lt;nums.size(); i++) &#123; maxproduct[i] = max(nums[i], max(nums[i]*maxproduct[i-1], nums[i]*minproduct[i-1])); minproduct[i] = min(nums[i], min(nums[i]*minproduct[i-1], nums[i]*maxproduct[i-1])); maxans = max(maxans, maxproduct[i]); &#125; return maxans; &#125; 测试：12345678int main() &#123; int a[] = &#123;2, 3, -2, 4&#125;; vector&lt;int&gt; b(a, a+sizeof(a)/sizeof(int)); printf(\"%d\\n\", maxProduct(b)); return 0;&#125; 输出：6 算法注意点： maxproduct是包含nums[i]时的局部最大值，maxans是全局最大值；算完maxproduct后一定别忘了更新全局最大值。1maxans = max(maxans, maxproduct[i]); 以上空间复杂度为O(n),所以可以用临时变量来算这样空间复杂度为O(n)： 12345678910111213141516171819int maxProduct(int[] A) &#123; if (A.length == 0) &#123; return 0; &#125; int maxherepre = A[0]; int minherepre = A[0]; int maxsofar = A[0]; int maxhere, minhere; for (int i = 1; i &lt; A.length; i++) &#123; maxhere = Math.max(Math.max(maxherepre * A[i], minherepre * A[i]), A[i]); minhere = Math.min(Math.min(maxherepre * A[i], minherepre * A[i]), A[i]); maxsofar = Math.max(maxhere, maxsofar); maxherepre = maxhere; minherepre = minhere; &#125; return maxsofar;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":" Minimum Path Sum","date":"2017-01-16T09:09:47.000Z","path":"2017/01/16/Minimum-Path-Sum/","text":"Minimum Path Sum 问题描述：leetcode:64 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. 给定一个m*n的矩阵，从左上角找一个到右下角的最短路径。 思路： 对于一点dp[i][j]到达其最短路径为从其上方dp[i][j-1]或者从其左方到达dp[i-1][j];所以对于dp[i][j]: 1dp[i][j] += min(dp[i-1][j] , dp[i][j-1]); 考虑边界情况：对于左边界：只能从上方到达： 1dp[i][0] += dp[i-1][0]; 对于上边界：只能从左方到达：1dp[0][i] += dp[0][i-1]; 代码：1234567891011121314int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;vector&lt;int&gt; &gt; &amp;dp = grid; int row = dp.size(); int col = dp[0].size(); for (int i = 1; i&lt;row; i++) dp[i][0] += dp[i-1][0]; for (int i = 1; i&lt;col; i++) dp[0][i] += dp[0][i-1]; for (int i=1; i&lt;row; i++)&#123; for (int j=1; j&lt;col; j++) &#123; dp[i][j] += min(dp[i-1][j] , dp[i][j-1]); &#125; &#125; return dp[row-1][col-1];&#125; 测试：12345678910111213int main() &#123; vector&lt;vector&lt;int&gt; &gt; b(3); int a[] = &#123;2,4,3,7&#125;; int a1[] = &#123;5,3,2,1&#125;; int a2[] = &#123;4,8,6,2&#125;; b[0].assign(a,a+4); b[1].assign(a1,a1+4); b[2].assign(a2,a2+4); printf(\"%d\\n\",minPathSum(b)); return 0;&#125; 输出：14 语法注意点： 使用vector定义二维数组：1vector&lt;vector&lt;int&gt; &gt; b(3); 定义了一个二维数组b，有3行；列数未知。注意：最后两个 &gt; &gt;中间有个空格。 vector定义的二维数组的行数： 1int row = dp.size(); vector定义的二维数组的列数： 1int col = dp[0].size(); vector定义的二维数组的赋值： 1234567vector&lt;vector&lt;int&gt; &gt; b(3);int a[] = &#123;2,4,3,7&#125;;int a1[] = &#123;5,3,2,1&#125;;int a2[] = &#123;4,8,6,2&#125;;b[0].assign(a,a+4);b[1].assign(a1,a1+4);b[2].assign(a2,a2+4);","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Rotate Array","date":"2017-01-12T17:51:23.000Z","path":"2017/01/13/Rotate-Array/","text":"旋转数组 问题描述，给定一个数组长度为n，要求把后k个元素yi移动至前面，前n-k个元素移动到后面。 思想 代码1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;void reverse(int nums[], int start, int end)&#123; while(start&lt;end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; return; &#125;int main() &#123; int n,k; int nums[] = &#123;1,2,3,4,5,6,7&#125;; scanf(\"%d%d\", &amp;n,&amp;k); reverse(nums, 0, n-k-1); reverse(nums, n-k, n-1); reverse(nums, 0, n-1); for (int i=0; i&lt;n; i++) &#123; printf(\"%d \", nums[i]); &#125; printf(\"\\n\"); return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"Climbing Stairs","date":"2017-01-12T08:54:00.000Z","path":"2017/01/12/Climbing-Stairs/","text":"爬楼梯问题 [TOC] leetCode70:Climbing Stairs 楼梯一共有n级,每次你只能爬1级或者2级。问:从底部爬到顶部一共有多少种不 同的路径? 斐波那契数列的递推公式 分析：考虑走楼梯的最后一步，可能时最后是跨一步到达顶部，也可能最后是跨两步到达顶部。当最后是跨一步到达顶部时，此情况有 f(n-1)种方式；当最后一步是两步跨到顶部时，有 f(n-2)种方法。 递归法代码：1234567891011121314151617181920#include &lt;stdio.h&gt;int climb(int n)&#123; if (n==1||n==2) &#123; return n; &#125; else &#123; return climb(n-1)+climb(n-2); &#125;&#125;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%d\\n\", climb(n)); &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(2^n)$$ 空间复杂度 O(n) 时间和空间复杂度是如何算出来的？！ 空间复杂度：其实该函数的执行可以用一个递归树来模拟（recursive tree），函数的执行过程对应二叉树的后序遍历序列。如下图所示： 所以空间复杂度也就是树的深度，树的深度为 n-1 所以算法的空间复杂度为:$$O(n)$$ 时间复杂度：由于是二叉树，且深度为 n－1 我们自然就想到时间复杂度为： $$O(2^n)$$但是该二叉树不是满二叉树，所以节点数并不是2^n，那么该如何分析呢？用放缩法： 所以说时间复杂度为：$$O(2^n)$$ 备忘录法 思考以上算法有什么缺陷？！ 如下图所示： 我们发现f(4)被执行了两次，f(3)被执行了三次，这明显是多余的步骤，那么我们有没有办法减少这些没必要的多余的执行步骤呢？ 方法：用数组记录已经算过的f(n)的值。 备忘录法代码：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;long record[100]=&#123;0&#125;;long climb(int n)&#123; if (record[n]!=0) &#123; return record[n]; &#125; if (n==1||n==2) &#123; record[n]=n; return n; &#125; else &#123; record[n] = climb(n-1)+climb(n-2); return record[n]; &#125;&#125;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%ld\\n\", climb(n)); &#125; return 0;&#125; 注意：有时由于题目给的n可能比较大，那么得到的结果会比较大，可能超过int类型的表示范围,比如华科当年研究生机试中就规定1&lt;=n&lt;90，这时如果使用int就超出范围，所以使用long 类型。 . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(n)$$ 由于新开辟了数组，所以空间复杂度为：$$O(n)$$由于计算过的值不会重复计算，所以时间复杂度为：$$O(n)$$ 动态规划法 动态规划法代码：1234567891011121314151617#include &lt;stdio.h&gt;long F[91];int main() &#123; int n; F[1] = 1; F[2] = 2; for(int i=3; i&lt;91; i++) F[i] = F[i-1] + F[i-2]; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%ld\\n\", F[n]); &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(n)$$ 状态压缩法 思考以上算法有什么缺陷？！缺陷：需要开辟大小为n的数据解决：用状态压缩法，值需要几个临时变量，而不需要开辟数组，从而减小空间复杂度。 状态压缩法,又称滚动数组、滑动窗又(Sliding Window),用于优化动态规划法 的空间复杂度。 状态压缩法代码：1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; if (n==1||n==2) &#123; printf(\"%d\\n\",n); &#125; else&#123; long a = 1; long b = 2; long ans = 0; for (int i=3; i&lt;=n; i++) &#123; ans = a+b; a = b; b = ans; &#125; printf(\"%ld\\n\", ans); &#125; &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(1)$$ 空间复杂度为O(1) 因为只是定义了几个变量。","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"","date":"2017-01-11T13:10:08.000Z","path":"2017/01/11/README/","text":"BlogBackup","tags":[]},{"title":"GCD(最大公约数)-LCM（最小公倍数）","date":"2017-01-11T11:07:57.000Z","path":"2017/01/11/GCD_LMD/","text":"最大公约数和最小公倍数 最大公约数算法描述： 古希腊数学家欧几里得(公元前330年—公元前275年)发明了一种巧妙的算法——辗转相除法,又称欧几里得算法:令较大数为m,较小数为n; 当m除以n的余数不等于0时,把n作为m,并把余数作为n,进行下一次循环; 当余数等于0时,返回n 最大公约数. 递归算法123456789101112131415161718192021#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; if (temp==0) &#123; return j; &#125; else&#123; return gcd(j, temp); &#125;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", gcd(a, b)); &#125; return 0;&#125; . 算法分析 key value 测试输入 m=100,n=44 测试输出 4 时间复杂度 O(lgM) 空间复杂度 O(lgM) 每执行一次循环,m或者n至少有一个缩小了2倍,故时间复杂度上限为log2M。 对于大量的随机测试样例,每次循环平均能使m与n的值缩小一个10进位,所以平 均复杂度为O(lgM)。 . 非递归算法123456789101112131415161718192021#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; while (temp!=0) &#123; i = j; j = temp; temp = i%j; &#125; return j;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", gcd(a, b)); &#125; return 0;&#125; . 算法分析 key value 测试输入 m=100,n=44 测试输出 4 时间复杂度 O(lgM) 空间复杂度 O(1) 每执行一次循环,m或者n至少有一个缩小了2倍,故时间复杂度上限为log2M。 对于大量的随机测试样例,每次循环平均能使m与n的值缩小一个10进位,所以平 均复杂度为O(lgM),但是没有使用到堆和栈所以空间复杂为1。 最小公倍数 最小公倍数算法描述： 求出最大公约数之后,最小公倍数(Least Common Multiple,简称LCM),就能迎 刃而解了。LCM(m,n) = mn/GCD(m,n) 比如,60与24的最大公约数为12,那么最小公倍数为:6024/12 = 120。 . 非递归算法1234567891011121314151617181920#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; while (temp!=0) &#123; i = j; j = temp; temp = i%j; &#125; return j;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", a*b/gcd(a, b)); &#125; return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"递归算法","slug":"递归算法","permalink":"http://yoursite.com/tags/递归算法/"}]},{"title":"My First Post","date":"2017-01-11T05:45:40.000Z","path":"2017/01/11/My-First-Post/","text":"","tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"},{"name":"杂物","slug":"杂物","permalink":"http://yoursite.com/tags/杂物/"}]},{"title":"Hello World","date":"2017-01-10T10:22:10.000Z","path":"2017/01/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]