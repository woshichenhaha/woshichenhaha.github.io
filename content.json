[{"title":"Best Time to Buy and Sell Stock IV","date":"2017-01-18T13:20:43.000Z","path":"2017/01/18/Best-Time-to-Buy-and-Sell-Stock-IV/","text":"Best Time to Buy and Sell Stock IV 问题描述：leetcode:188 Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most k transactions.Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 思路： 按照思路写的代码：1234567891011121314151617int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(k==0||prices.size()&lt;2)&#123; return 0; &#125; &#125; int maxdiff = 0; vector&lt;vector&lt;int&gt; &gt; T(k+1, vector&lt;int&gt; (prices.size(), 0)); for(int i=1; i&lt;k+1; i++)&#123; maxdiff = T[i-1][0] - prices[0] ; for(int j=1; j&lt;prices.size(); j++)&#123; T[i][j] = max(T[i][j-1], maxdiff+prices[j]); maxdiff = max(maxdiff, T[i-1][j] - prices[j]); &#125; &#125; return T[k][prices.size()-1]; &#125; 但是该代码运行时会报错： 也就是说当k＝1000000000时会导致内存出错；所以可以优化代码，也就是当1k&gt;prices.size() 时使用不限定交易次数时的算法（Best Time to Buy and Sell Stock II；leetcode122） 修改之后代码：12345678910111213141516171819202122232425int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(k==0||prices.size()&lt;2)&#123; return 0; &#125; if(k&gt;prices.size())&#123; int ans = 0; for(int i=1; i&lt;prices.size(); i++)&#123; if(prices[i]&gt;prices[i-1])&#123; ans += (prices[i]-prices[i-1]); &#125; &#125; return ans; &#125; int maxdiff = 0; vector&lt;vector&lt;int&gt; &gt; T(k+1, vector&lt;int&gt; (prices.size(), 0)); for(int i=1; i&lt;k+1; i++)&#123; maxdiff = T[i-1][0] - prices[0] ; for(int j=1; j&lt;prices.size(); j++)&#123; T[i][j] = max(T[i][j-1], maxdiff+prices[j]); maxdiff = max(maxdiff, T[i-1][j] - prices[j]); &#125; &#125; return T[k][prices.size()-1];&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Maximum Product Subarray","date":"2017-01-16T14:02:33.000Z","path":"2017/01/16/Maximum-Product-Subarray/","text":"Maximum Product Subarray 问题描述：leetcode:152 Find the contiguous subarray within an array (containing at least one number) which has the largest product.For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. 给定一个数组，找出该数组的连续字串中乘积最大的值；比如给定 [2,3,-2,4]，则答案时当为 [2,3]时，答案为6。 思路： 数组中的元素可以为正也可以为负。 设置两个数组，分别记录包括当前元素在内的字串所能构成的最大和最小值。 至于当前最大（包括当前元素），可能是之前最大乘以当前元素、也可能是前一个元素最小乘以当前元素、也可能是当前元素。 然后根据当前元素最大更新全局元素最大。 该问题是dp问题，也是dp问题中的局部最优和全局最优问题。 代码：12345678910111213141516int maxProduct(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; maxproduct(nums.size(),0); vector&lt;int&gt; minproduct(nums.size(),0); maxproduct[0] = nums[0]; minproduct[0] = nums[0]; int maxans = nums[0]; for (int i=1; i&lt;nums.size(); i++) &#123; maxproduct[i] = max(nums[i], max(nums[i]*maxproduct[i-1], nums[i]*minproduct[i-1])); minproduct[i] = min(nums[i], min(nums[i]*minproduct[i-1], nums[i]*maxproduct[i-1])); maxans = max(maxans, maxproduct[i]); &#125; return maxans; &#125; 测试：12345678int main() &#123; int a[] = &#123;2, 3, -2, 4&#125;; vector&lt;int&gt; b(a, a+sizeof(a)/sizeof(int)); printf(\"%d\\n\", maxProduct(b)); return 0;&#125; 输出：6 算法注意点： maxproduct是包含nums[i]时的局部最大值，maxans是全局最大值；算完maxproduct后一定别忘了更新全局最大值。1maxans = max(maxans, maxproduct[i]); 以上空间复杂度为O(n),所以可以用临时变量来算这样空间复杂度为O(n)： 12345678910111213141516171819int maxProduct(int[] A) &#123; if (A.length == 0) &#123; return 0; &#125; int maxherepre = A[0]; int minherepre = A[0]; int maxsofar = A[0]; int maxhere, minhere; for (int i = 1; i &lt; A.length; i++) &#123; maxhere = Math.max(Math.max(maxherepre * A[i], minherepre * A[i]), A[i]); minhere = Math.min(Math.min(maxherepre * A[i], minherepre * A[i]), A[i]); maxsofar = Math.max(maxhere, maxsofar); maxherepre = maxhere; minherepre = minhere; &#125; return maxsofar;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":" Minimum Path Sum","date":"2017-01-16T09:09:47.000Z","path":"2017/01/16/Minimum-Path-Sum/","text":"Minimum Path Sum 问题描述：leetcode:64 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. 给定一个m*n的矩阵，从左上角找一个到右下角的最短路径。 思路： 对于一点dp[i][j]到达其最短路径为从其上方dp[i][j-1]或者从其左方到达dp[i-1][j];所以对于dp[i][j]: 1dp[i][j] += min(dp[i-1][j] , dp[i][j-1]); 考虑边界情况：对于左边界：只能从上方到达： 1dp[i][0] += dp[i-1][0]; 对于上边界：只能从左方到达：1dp[0][i] += dp[0][i-1]; 代码：1234567891011121314int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;vector&lt;int&gt; &gt; &amp;dp = grid; int row = dp.size(); int col = dp[0].size(); for (int i = 1; i&lt;row; i++) dp[i][0] += dp[i-1][0]; for (int i = 1; i&lt;col; i++) dp[0][i] += dp[0][i-1]; for (int i=1; i&lt;row; i++)&#123; for (int j=1; j&lt;col; j++) &#123; dp[i][j] += min(dp[i-1][j] , dp[i][j-1]); &#125; &#125; return dp[row-1][col-1];&#125; 测试：12345678910111213int main() &#123; vector&lt;vector&lt;int&gt; &gt; b(3); int a[] = &#123;2,4,3,7&#125;; int a1[] = &#123;5,3,2,1&#125;; int a2[] = &#123;4,8,6,2&#125;; b[0].assign(a,a+4); b[1].assign(a1,a1+4); b[2].assign(a2,a2+4); printf(\"%d\\n\",minPathSum(b)); return 0;&#125; 输出：14 语法注意点： 使用vector定义二维数组：1vector&lt;vector&lt;int&gt; &gt; b(3); 定义了一个二维数组b，有3行；列数未知。注意：最后两个 &gt; &gt;中间有个空格。 vector定义的二维数组的行数： 1int row = dp.size(); vector定义的二维数组的列数： 1int col = dp[0].size(); vector定义的二维数组的赋值： 1234567vector&lt;vector&lt;int&gt; &gt; b(3);int a[] = &#123;2,4,3,7&#125;;int a1[] = &#123;5,3,2,1&#125;;int a2[] = &#123;4,8,6,2&#125;;b[0].assign(a,a+4);b[1].assign(a1,a1+4);b[2].assign(a2,a2+4);","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Rotate Array","date":"2017-01-12T17:51:23.000Z","path":"2017/01/13/Rotate-Array/","text":"旋转数组 问题描述，给定一个数组长度为n，要求把后k个元素yi移动至前面，前n-k个元素移动到后面。 思想 代码1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;void reverse(int nums[], int start, int end)&#123; while(start&lt;end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; return; &#125;int main() &#123; int n,k; int nums[] = &#123;1,2,3,4,5,6,7&#125;; scanf(\"%d%d\", &amp;n,&amp;k); reverse(nums, 0, n-k-1); reverse(nums, n-k, n-1); reverse(nums, 0, n-1); for (int i=0; i&lt;n; i++) &#123; printf(\"%d \", nums[i]); &#125; printf(\"\\n\"); return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"Climbing Stairs","date":"2017-01-12T08:54:00.000Z","path":"2017/01/12/Climbing-Stairs/","text":"爬楼梯问题 [TOC] leetCode70:Climbing Stairs 楼梯一共有n级,每次你只能爬1级或者2级。问:从底部爬到顶部一共有多少种不 同的路径? 斐波那契数列的递推公式 分析：考虑走楼梯的最后一步，可能时最后是跨一步到达顶部，也可能最后是跨两步到达顶部。当最后是跨一步到达顶部时，此情况有 f(n-1)种方式；当最后一步是两步跨到顶部时，有 f(n-2)种方法。 递归法代码：1234567891011121314151617181920#include &lt;stdio.h&gt;int climb(int n)&#123; if (n==1||n==2) &#123; return n; &#125; else &#123; return climb(n-1)+climb(n-2); &#125;&#125;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%d\\n\", climb(n)); &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(2^n)$$ 空间复杂度 O(n) 时间和空间复杂度是如何算出来的？！ 空间复杂度：其实该函数的执行可以用一个递归树来模拟（recursive tree），函数的执行过程对应二叉树的后序遍历序列。如下图所示： 所以空间复杂度也就是树的深度，树的深度为 n-1 所以算法的空间复杂度为:$$O(n)$$ 时间复杂度：由于是二叉树，且深度为 n－1 我们自然就想到时间复杂度为： $$O(2^n)$$但是该二叉树不是满二叉树，所以节点数并不是2^n，那么该如何分析呢？用放缩法： 所以说时间复杂度为：$$O(2^n)$$ 备忘录法 思考以上算法有什么缺陷？！ 如下图所示： 我们发现f(4)被执行了两次，f(3)被执行了三次，这明显是多余的步骤，那么我们有没有办法减少这些没必要的多余的执行步骤呢？ 方法：用数组记录已经算过的f(n)的值。 备忘录法代码：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;long record[100]=&#123;0&#125;;long climb(int n)&#123; if (record[n]!=0) &#123; return record[n]; &#125; if (n==1||n==2) &#123; record[n]=n; return n; &#125; else &#123; record[n] = climb(n-1)+climb(n-2); return record[n]; &#125;&#125;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%ld\\n\", climb(n)); &#125; return 0;&#125; 注意：有时由于题目给的n可能比较大，那么得到的结果会比较大，可能超过int类型的表示范围,比如华科当年研究生机试中就规定1&lt;=n&lt;90，这时如果使用int就超出范围，所以使用long 类型。 . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(n)$$ 由于新开辟了数组，所以空间复杂度为：$$O(n)$$由于计算过的值不会重复计算，所以时间复杂度为：$$O(n)$$ 动态规划法 动态规划法代码：1234567891011121314151617#include &lt;stdio.h&gt;long F[91];int main() &#123; int n; F[1] = 1; F[2] = 2; for(int i=3; i&lt;91; i++) F[i] = F[i-1] + F[i-2]; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%ld\\n\", F[n]); &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(n)$$ 状态压缩法 思考以上算法有什么缺陷？！缺陷：需要开辟大小为n的数据解决：用状态压缩法，值需要几个临时变量，而不需要开辟数组，从而减小空间复杂度。 状态压缩法,又称滚动数组、滑动窗又(Sliding Window),用于优化动态规划法 的空间复杂度。 状态压缩法代码：1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; if (n==1||n==2) &#123; printf(\"%d\\n\",n); &#125; else&#123; long a = 1; long b = 2; long ans = 0; for (int i=3; i&lt;=n; i++) &#123; ans = a+b; a = b; b = ans; &#125; printf(\"%ld\\n\", ans); &#125; &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(1)$$ 空间复杂度为O(1) 因为只是定义了几个变量。","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"","date":"2017-01-11T13:10:08.000Z","path":"2017/01/11/README/","text":"BlogBackup","tags":[]},{"title":"GCD(最大公约数)-LCM（最小公倍数）","date":"2017-01-11T11:07:57.000Z","path":"2017/01/11/GCD_LMD/","text":"最大公约数和最小公倍数 最大公约数算法描述： 古希腊数学家欧几里得(公元前330年—公元前275年)发明了一种巧妙的算法——辗转相除法,又称欧几里得算法:令较大数为m,较小数为n; 当m除以n的余数不等于0时,把n作为m,并把余数作为n,进行下一次循环; 当余数等于0时,返回n 最大公约数. 递归算法123456789101112131415161718192021#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; if (temp==0) &#123; return j; &#125; else&#123; return gcd(j, temp); &#125;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", gcd(a, b)); &#125; return 0;&#125; . 算法分析 key value 测试输入 m=100,n=44 测试输出 4 时间复杂度 O(lgM) 空间复杂度 O(lgM) 每执行一次循环,m或者n至少有一个缩小了2倍,故时间复杂度上限为log2M。 对于大量的随机测试样例,每次循环平均能使m与n的值缩小一个10进位,所以平 均复杂度为O(lgM)。 . 非递归算法123456789101112131415161718192021#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; while (temp!=0) &#123; i = j; j = temp; temp = i%j; &#125; return j;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", gcd(a, b)); &#125; return 0;&#125; . 算法分析 key value 测试输入 m=100,n=44 测试输出 4 时间复杂度 O(lgM) 空间复杂度 O(1) 每执行一次循环,m或者n至少有一个缩小了2倍,故时间复杂度上限为log2M。 对于大量的随机测试样例,每次循环平均能使m与n的值缩小一个10进位,所以平 均复杂度为O(lgM),但是没有使用到堆和栈所以空间复杂为1。 最小公倍数 最小公倍数算法描述： 求出最大公约数之后,最小公倍数(Least Common Multiple,简称LCM),就能迎 刃而解了。LCM(m,n) = mn/GCD(m,n) 比如,60与24的最大公约数为12,那么最小公倍数为:6024/12 = 120。 . 非递归算法1234567891011121314151617181920#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; while (temp!=0) &#123; i = j; j = temp; temp = i%j; &#125; return j;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", a*b/gcd(a, b)); &#125; return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"递归算法","slug":"递归算法","permalink":"http://yoursite.com/tags/递归算法/"}]},{"title":"My First Post","date":"2017-01-11T05:45:40.000Z","path":"2017/01/11/My-First-Post/","text":"","tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"},{"name":"杂物","slug":"杂物","permalink":"http://yoursite.com/tags/杂物/"}]},{"title":"Hello World","date":"2017-01-10T10:22:10.000Z","path":"2017/01/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]