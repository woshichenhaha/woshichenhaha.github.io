[{"title":"Rotate Array","date":"2017-01-12T17:51:23.000Z","path":"2017/01/13/Rotate-Array/","text":"旋转数组 问题描述，给定一个数组长度为n，要求把后k个元素yi移动至前面，前n-k个元素移动到后面。 思想 代码1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;void reverse(int nums[], int start, int end)&#123; while(start&lt;end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; return; &#125;int main() &#123; int n,k; int nums[] = &#123;1,2,3,4,5,6,7&#125;; scanf(\"%d%d\", &amp;n,&amp;k); reverse(nums, 0, n-k-1); reverse(nums, n-k, n-1); reverse(nums, 0, n-1); for (int i=0; i&lt;n; i++) &#123; printf(\"%d \", nums[i]); &#125; printf(\"\\n\"); return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"Climbing Stairs","date":"2017-01-12T08:54:00.000Z","path":"2017/01/12/Climbing-Stairs/","text":"爬楼梯问题 [TOC] leetCode70:Climbing Stairs 楼梯一共有n级,每次你只能爬1级或者2级。问:从底部爬到顶部一共有多少种不 同的路径? 斐波那契数列的递推公式 分析：考虑走楼梯的最后一步，可能时最后是跨一步到达顶部，也可能最后是跨两步到达顶部。当最后是跨一步到达顶部时，此情况有 f(n-1)种方式；当最后一步是两步跨到顶部时，有 f(n-2)种方法。 递归法代码：1234567891011121314151617181920#include &lt;stdio.h&gt;int climb(int n)&#123; if (n==1||n==2) &#123; return n; &#125; else &#123; return climb(n-1)+climb(n-2); &#125;&#125;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%d\\n\", climb(n)); &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(2^n)$$ 空间复杂度 O(n) 时间和空间复杂度是如何算出来的？！ 空间复杂度：其实该函数的执行可以用一个递归树来模拟（recursive tree），函数的执行过程对应二叉树的后序遍历序列。如下图所示： 所以空间复杂度也就是树的深度，树的深度为 n-1 所以算法的空间复杂度为:$$O(n)$$ 时间复杂度：由于是二叉树，且深度为 n－1 我们自然就想到时间复杂度为： $$O(2^n)$$但是该二叉树不是满二叉树，所以节点数并不是2^n，那么该如何分析呢？用放缩法： 所以说时间复杂度为：$$O(2^n)$$ 备忘录法 思考以上算法有什么缺陷？！ 如下图所示： 我们发现f(4)被执行了两次，f(3)被执行了三次，这明显是多余的步骤，那么我们有没有办法减少这些没必要的多余的执行步骤呢？ 方法：用数组记录已经算过的f(n)的值。 备忘录法代码：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;long record[100]=&#123;0&#125;;long climb(int n)&#123; if (record[n]!=0) &#123; return record[n]; &#125; if (n==1||n==2) &#123; record[n]=n; return n; &#125; else &#123; record[n] = climb(n-1)+climb(n-2); return record[n]; &#125;&#125;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%ld\\n\", climb(n)); &#125; return 0;&#125; 注意：有时由于题目给的n可能比较大，那么得到的结果会比较大，可能超过int类型的表示范围,比如华科当年研究生机试中就规定1&lt;=n&lt;90，这时如果使用int就超出范围，所以使用long 类型。 . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(n)$$ 由于新开辟了数组，所以空间复杂度为：$$O(n)$$由于计算过的值不会重复计算，所以时间复杂度为：$$O(n)$$ 动态规划法 动态规划法代码：1234567891011121314151617#include &lt;stdio.h&gt;long F[91];int main() &#123; int n; F[1] = 1; F[2] = 2; for(int i=3; i&lt;91; i++) F[i] = F[i-1] + F[i-2]; while (scanf(\"%d\", &amp;n)!= EOF) &#123; printf(\"%ld\\n\", F[n]); &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(n)$$ 状态压缩法 思考以上算法有什么缺陷？！缺陷：需要开辟大小为n的数据解决：用状态压缩法，值需要几个临时变量，而不需要开辟数组，从而减小空间复杂度。 状态压缩法,又称滚动数组、滑动窗又(Sliding Window),用于优化动态规划法 的空间复杂度。 状态压缩法代码：1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main() &#123; int n; while (scanf(\"%d\", &amp;n)!= EOF) &#123; if (n==1||n==2) &#123; printf(\"%d\\n\",n); &#125; else&#123; long a = 1; long b = 2; long ans = 0; for (int i=3; i&lt;=n; i++) &#123; ans = a+b; a = b; b = ans; &#125; printf(\"%ld\\n\", ans); &#125; &#125; return 0;&#125; . 算法分析 key value 测试输入 7 测试输出 21 时间复杂度 $$O(n)$$ 空间复杂度 $$O(1)$$ 空间复杂度为O(1) 因为只是定义了几个变量。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"","date":"2017-01-11T13:10:08.000Z","path":"2017/01/11/README/","text":"BlogBackup","tags":[]},{"title":"GCD(最大公约数)-LCM（最小公倍数）","date":"2017-01-11T11:07:57.000Z","path":"2017/01/11/GCD_LMD/","text":"最大公约数和最小公倍数 最大公约数算法描述： 古希腊数学家欧几里得(公元前330年—公元前275年)发明了一种巧妙的算法——辗转相除法,又称欧几里得算法:令较大数为m,较小数为n; 当m除以n的余数不等于0时,把n作为m,并把余数作为n,进行下一次循环; 当余数等于0时,返回n 最大公约数. 递归算法123456789101112131415161718192021#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; if (temp==0) &#123; return j; &#125; else&#123; return gcd(j, temp); &#125;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", gcd(a, b)); &#125; return 0;&#125; . 算法分析 key value 测试输入 m=100,n=44 测试输出 4 时间复杂度 O(lgM) 空间复杂度 O(lgM) 每执行一次循环,m或者n至少有一个缩小了2倍,故时间复杂度上限为log2M。 对于大量的随机测试样例,每次循环平均能使m与n的值缩小一个10进位,所以平 均复杂度为O(lgM)。 . 非递归算法123456789101112131415161718192021#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; while (temp!=0) &#123; i = j; j = temp; temp = i%j; &#125; return j;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", gcd(a, b)); &#125; return 0;&#125; . 算法分析 key value 测试输入 m=100,n=44 测试输出 4 时间复杂度 O(lgM) 空间复杂度 O(1) 每执行一次循环,m或者n至少有一个缩小了2倍,故时间复杂度上限为log2M。 对于大量的随机测试样例,每次循环平均能使m与n的值缩小一个10进位,所以平 均复杂度为O(lgM),但是没有使用到堆和栈所以空间复杂为1。 最小公倍数 最小公倍数算法描述： 求出最大公约数之后,最小公倍数(Least Common Multiple,简称LCM),就能迎 刃而解了。LCM(m,n) = mn/GCD(m,n) 比如,60与24的最大公约数为12,那么最小公倍数为:6024/12 = 120。 . 非递归算法1234567891011121314151617181920#include &lt;stdio.h&gt;int gcd(int i, int j)&#123; int temp = i%j; while (temp!=0) &#123; i = j; j = temp; temp = i%j; &#125; return j;&#125;int main() &#123; int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b)!=0) &#123; printf(\"%d\\n\", a*b/gcd(a, b)); &#125; return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"递归算法","slug":"递归算法","permalink":"http://yoursite.com/tags/递归算法/"}]},{"title":"My First Post","date":"2017-01-11T05:45:40.000Z","path":"2017/01/11/My-First-Post/","text":"","tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"},{"name":"杂物","slug":"杂物","permalink":"http://yoursite.com/tags/杂物/"}]},{"title":"Hello World","date":"2017-01-10T10:22:10.000Z","path":"2017/01/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]